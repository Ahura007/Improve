using static System.Runtime.InteropServices.JavaScript.JSType;
using System;

namespace _2._1
{
    internal class Program
    {
        static void Main(string[] args)
        {

            //1-What statement can you type in a C# file to discover the compiler and language version?
            var csharpVersion = $"C# {Environment.Version}";
            Console.WriteLine($"Compiler and Language Version: {csharpVersion}");


            //2-What are the two types of comments in C#?  
            /*
            This is a multi-line comment.It can span across multiple lines.
            Another way Ctrl+K,C
            */


            //3-What is the difference between a verbatim string and an interpolated string?
            var verbatimStrings = @"C:\MyFolder\MyFile.txt";


            var name = "Alice";
            var age = 30;
            var interpolatedString = $"My name is {name} and I am {age} years old.";


            //4- Why should you be careful when using float and double values?
            // این موارد سرچ  کردم بر خوردم جالب بودم

            //خطاهای گرد کردن:
            //مقادیر شناور و دوگانه دقت محدودی دارند، به این معنی که نمی توانند تمام اعداد واقعی را دقیقاً نشان دهند.در نتیجه، وقتی عملیات حسابی را روی این مقادیر انجام می‌دهید، خطاهای گرد کردن ممکن است جمع شوند و منجر به نتایج غیرمنتظره شوند.

            //    از دست دادن دقت:
            //وقتی یک عدد واقعی را در یک متغیر شناور یا دوتایی ذخیره می‌کنید، ممکن است مقداری دقت را از دست بدهید. به عنوان مثال، کسرهای اعشاری ممکن است به طور دقیق نشان داده نشوند، که منجر به عدم دقت کوچک در محاسبات می شود.

            //    مقایسه دشوار است:
            //به دلیل خطاهای گرد کردن، مقایسه دو مقدار شناور یا دو مقدار برای برابری می تواند مشکل ساز باشد. اغلب بهتر است آنها را با یک آستانه تحمل(مثلاً در یک مقدار اپسیلون کوچک) مقایسه کنید تا تغییرات کوچک را در نظر بگیرید.

            //    برای محاسبات اعشاری دقیق مناسب نیست:
            //Float و double برای محاسبات مالی یا پولی که در آن محاسبات دقیق اعشاری مورد نیاز است مناسب نیستند.برای چنین مواردی، نوع اعشاری مناسب تر است.

            //    اعداد غیر عادی:
            //Float و double می توانند اعداد بسیار کمی را نشان دهند، اما این کار را با دقت کمتری انجام می دهند، که می تواند منجر به از دست دادن دقت در هنگام برخورد با مقادیر بسیار کوچک شود.

            //    از دست دادن اهمیت:
            //کم کردن دو عدد تقریباً مساوی می تواند منجر به کاهش قابل توجه دقت شود.این به عنوان از دست دادن اهمیت شناخته می شود و در هنگام برخورد با الگوریتم های عددی می تواند مشکل ساز باشد.

            //    رفتار وابسته به پلت فرم:
            //رفتار float و double می تواند در سخت افزارها و پلتفرم های مختلف متفاوت باشد، به این معنی که یک کد ممکن است نتایج کمی متفاوت در سیستم های مختلف ایجاد کند.

            //    مفاهیم عملکرد:
            //در برخی موارد، انجام محاسبات با دقت مضاعف(دوبرابر) می تواند کندتر از دقت تکی(float) در معماری های سخت افزاری خاص باشد.بنابراین، انتخاب دقت مناسب نیز می تواند بر عملکرد تأثیر بگذارد.



            //5- How can you determine how many bytes a type like double uses in memory ?
            var sizeInBytes = sizeof(double);
            Console.WriteLine($"The size of a double is {sizeInBytes} bytes.");

            //6-When should you use the var keyword ?
            //always


            //7-What is the newest syntax to create an instance of a class like XmlDocument?
            var xmlDoc = new System.Xml.XmlDocument();




            //8-Why should you be careful when using the dynamic type?
            //عدم بررسی نوع Compile-Time: مهم ترین اشکال دینامیک این است که بررسی نوع را به زمان اجرا موکول می کند. این بدان معنی است که خطاهای مربوط به نوع، مانند عدم تطابق روش یا نام ویژگی یا عملیات نامعتبر، در زمان کامپایل شناسایی نمی شوند. این خطاها می تواند منجر به استثناهای زمان اجرا شود و اشکال زدایی را چالش برانگیزتر کند.

            //    از دست دادن Intellisense و Code Assistance: از آنجایی که کامپایلر تا زمان اجرا نوع متغیر پویا را نمی‌داند، شما مزایای intellisense و کمک کد را در محیط توسعه خود از دست می‌دهید. در حین تایپ، پیشنهادها یا هشدارهای مفیدی دریافت نخواهید کرد، و این امر معرفی خطاها را آسان‌تر می‌کند.

            //    پیچیدگی اشکال زدایی: هنگامی که مشکلاتی با انواع پویا ایجاد می شود، اشکال زدایی می تواند چالش برانگیزتر شود زیرا پیام های خطای زمان کامپایل یا اطلاعات نوع دقیق را در اختیار نخواهید داشت.

            //    کدهای کمتر قابل پیش بینی: کدهایی که به شدت به دینامیک متکی هستند، برای توسعه دهندگان دیگر کمتر قابل پیش بینی و درک آن دشوارتر است.ممکن است مشخص نباشد که یک شی واقعاً از چه روش‌ها یا ویژگی‌هایی پشتیبانی می‌کند که منجر به سردرگمی می‌شود.

            //    سربار عملکرد: استفاده از دینامیک به دلیل نیاز به بررسی نوع زمان اجرا و اتصال دیرهنگام می تواند سربار عملکرد را معرفی کند.ممکن است برای کدهای حیاتی عملکرد مناسب نباشد.

            //    پشتیبانی محدود IDE: برخی از ابزارهای تجزیه و تحلیل کد و ویژگی‌های IDE که به شما در حفظ کیفیت و صحت کد کمک می‌کنند، ممکن است با انواع پویا کارایی نداشته باشند.

            //    پتانسیل برای استثناهای زمان اجرا: از آنجایی که داینامیک در زمان کامپایل بررسی نوع را انجام نمی دهد، ممکن است هنگام تلاش برای فراخوانی متدها یا دسترسی به ویژگی هایی که در زمان اجرا روی شی وجود ندارند، با استثناهای زمان اجرا مواجه شوید.

            //    پشتیبانی محدود Refactoring: تغییر نام متغیرها، روش‌ها یا ویژگی‌ها می‌تواند زمانی که از پویا استفاده می‌کنید بیشتر مستعد خطا باشد، زیرا کامپایلر همه مکان‌هایی را که باید تغییرات انجام شود را نمی‌گیرد.





            //9-How do you right-align a format string?
            var text = "Hello";
            var width = 10;
            var formattedString = string.Format("{0,10}", text);
            Console.WriteLine(formattedString);
        }
    }
}