using System.ComponentModel;
using System.Diagnostics;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace _4._1
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //1. What does the C# keyword void mean?    return nothing


            //2.What are some differences between imperative and functional programming styles ?
            // سبک‌های محبوب و شیوه‌های اساسی برنامه‌نویسی وجود دارد  
            //به این شیوه‌های اساسی برنامه‌نویسی،‌ پارادایم برنامه نویسی می‌گویند مثل

            //برنامه‌نویسی دستوری(Imperative programming)

            //برنامه‌نویسی شی‌گرا(object-oriented)

            //برنامه‌نویسی اعلانی(Declarative programming)

            //برنامه‌نویسی رویه‌ای(procedural)

            //برنامه‌نویسی تابعی(functional)

            //برنامه‌نویسی منطقی(logic)

            //برنامه‌نویسی سمبلیک(Symbolic programming)

            //برنامه‌نویسی موازی(Parallel programming)



            // imperative  الگوی
            //این الگو بیان می‌کنه که کدزدن باید به نحوی باشه که برای حاصل شدن یک نتیجه خاص تمام مراحل اون رو قدم به قدم برای برنامه توضیح بدیم.
            //درست مثل دستور پخت غذا.مرحله به مرحله و با جزئیات.

            // object-oriented الگو 
            // این بر اساس مفهوم اشیا است


            // declarative الگوی
            //اما در عوض الگوی declarative می‌گه که شما باید نتیجه‌ای که میخواید حاصل بشه رو برای برنامه توصیف کنین.
            //درواقع اینطور درنظر بگیرید که الگوی قبلی ‌‌do to How و این الگو do to What هست.دیگه ما مرحله به مرحله تسک‌ها رو به برنامه امر نمیکنیم.
            //دیگه طرز پختی درکار نیست.فقط غذایی رو که میخوایم توصیف میکنیم


            // procedural الگوی
            //یک الگوی برنامه‌نویسی ساده که این بر اساس مفهوم تماس های رویه ای است
            //به رویه همان متد یا تابع نیز می‌گویند
            // که به شما امکان می‌دهد تا به دفعات مورد نیاز، از کد دوباره استفاده کنید.



            // functional الگوی
            //اصل مهم این الگو اجرای یک سری توابع است. 
            //در این رویکرد، با توابع اصلی تریتن رکن  محسوب میشوند و شناسه های محلی هم به عنوان ارگومان که قابل بازگشت از توابع دیگر هستند، 


            //logic programing الگو
            //این بر اساس منطق رسمی است.
            //برنامه ها شامل مجموعه ای از جملات به شکل منطقی، بیان کننده حقایق و قواعد مربوط به برخی از حوزه های مسئله است.
            //ماشین آلات براساس دانش بنیادی که از قبل شناخته شده است، نتیجه می‌گیرند. 
            //. زبان‌هایی مانند Prolog ، Mercury و غیره از برنامه نویسی منطقی پشتیبانی می کنند.


            //Parallel programming الگو
            //شکستن قسمتهای مختلف یک کار در بین چندین پردازنده به کاهش زمان اجرای برنامه کمک می‌کند. 







            // اکنون به مقایسه این دو پارادایم برنامه نویسی میپردازیم


            //مدیریت وضعیت متغییرها
            //Imperative programming
            //تغییر وضعیت برنامه با دادن یک سری مراحل و دستورات صریح  
            //به متغیرهای قابل تغییر متکی است و اغلب از عباراتی مانند انتساب، حلقه‌ها و شرطی‌ها برای تغییر وضعیت برنامه استفاده می‌شود.

            // Functional Programming 
            // دقیقا بر عکس الگوی فوق برنامه نویسی تابعی از دادهای تغغیر ناپذیز استفاده میکند 





            //work flow
            //Imperative programming
            //  کد دستوری اغلب شامل ساختارهای جریان کنترل صریح مانند حلقه ها عبارات شرطی است
            // معمولاً حول عباراتی سازماندهی می شود که نحوه دستیابی به یک نتیجه خاص را مشخص می کند.

            // Functional Programming 
            //به جای اینکه مشخص کند چگونه یک کار را انجام دهید، بر روی آنچه که وظیفه باید انجام دهد تمرکز می کند.



            //Side Effects:
            //Imperative programming
            //اشکال زدایی و استدلال در مورد کد به دلیل عوارض جانبی غیرمنتظره می تواند پیچیده باشد.

            // Functional Programming 
            //   هدف کد عملکردی به حداقل رساندن عوارض جانبی است.
            //توابع به گونه‌ای طراحی شده‌اند که خالص باشند، به این معنی که هیچ عارضه جانبی ندارند، که باعث می‌شود کد قابل پیش‌بینی‌تر و آسان‌تر آزمایش و استدلال شود.




            //Mutability
            //Imperative programming
            //شامل متغیرهای قابل تغییر است که می توانند در طول اجرای برنامه تغییر یابند
            // این می تواند به مسائلی مانند شرایط مسابقه و اشکال زدایی پیچیده منجر شود.

            // Functional Programming 
            //برنامه نویسی تابعی تغییر ناپذیری را ترجیح می دهد.
            //هنگامی که یک ساختار داده ایجاد می شود، نباید تغییر کند.
            //این امر پتانسیل اشکالات را کاهش می دهد و استدلال در مورد تبدیل داده ها را آسان تر می کند.





            //Concurrency and Parallelism
            //Imperative programming
            //مدیریت همزمانی و موازی بودن می تواند در برنامه نویسی امری به دلیل حالت تغییرپذیر چالش برانگیز باشد.
            //اغلب به قفل ها و مکانیسم های همگام سازی برای مدیریت دسترسی همزمان به منابع مشترک متکی است.

            // Functional Programming 
            //برای مدیریت همزمانی و موازی سازی مناسب تر است،
            //زیرا تغییر ناپذیری استدلال در مورد بسیاری از مسائل رایج مرتبط با همزمانی را آسان تر می کند و از آن اجتناب می کند.







            // 3. In Visual Studio Code or Visual Studio, what is the difference between pressing F5, Ctrl or Cmd + F5, Shift + F5, and Ctrl or Cmd +Shift + F5 ?
            //F5(Start Debugging)
            //Ctrl or Cmd + F5(Start Without Debugging)
            //Shift + F5(Stop Debugging)
            //Ctrl or Cmd + Shift + F5(Restart Debugging)



            //4.Where does the Trace.WriteLine method write its output to?
            // برای لاگ گیری و تریس کردن کد استفاده میشود  و خروجی خود را روس چند trace listner
            // پیش فرض که در دات نت پیکر بندی شدهاند ثبت میکند

            //1. به‌طور پیش‌فرض، خروجی «Trace.WriteLine» به دیباگر سیستم ارسال می‌شود 
            Trace.WriteLine("aaaaaa");


            //با کانفیگ شنونده میتونا خروجی با کنسول پیکر بندی کرد 
            Trace.Listeners.Add(new ConsoleTraceListener());

            //با کانفیگ شنونده میتونا خروجی با  استریم فایل پیکر بندی کرد 
            Trace.Listeners.Add(new DelimitedListTraceListener("aaa"));

            // همچنین امکان ااضافه شدن شنونده سفارسی هم  وجود دارد


            //5.What are the five trace levels ?
            //در دات نت، پنج سطح ردیابی استاندارد وجود دارد که معمولاً برای اهداف ثبت و ردیابی استفاده می شود.
            //این سطوح ردیابی به شما امکان می دهد پیام های گزارش یا خروجی ردیابی را بر اساس شدت و اهمیت آنها دسته بندی و اولویت بندی کنید.
            //پنج سطح ردیابی که به ترتیب افزایش شدت فهرست شده اند، به شرح زیر است

            //A- debug
            //-کم شدت ترین سطح ردیابی.
            //-برای اطلاعات دقیق، اشکال زدایی پیام ها یا اطلاعاتی که می تواند به شما در درک جریان برنامه کمک کند استفاده می شود.
            //-اغلب در طول توسعه و اشکال زدایی استفاده می شود.
            //- معمولاً با سطح ردیابی 1 یا کمتر همراه است.


            // B- information
            //-برای اطلاعات عمومی یا رویدادهای مهم استفاده می شود.
            //-معمولاً برای اطلاعات غیر مرتبط خطا استفاده می شود که می تواند برای نظارت بر رفتار برنامه مفید باشد.
            //- معمولاً با سطح ردیابی 2 همراه است.

            // C -Warning
            // برای مسائل یا هشدارهای احتمالی استفاده می شود که مانع از اجرای برنامه نمی شود اما باید بررسی شود.
            //این پیام‌ها موقعیت‌هایی را نشان می‌دهند که ممکن است در آینده منجر به خطا شوند.
            // معمولاً با سطح ردیابی 3 همراه است.

            //D-Error
            // برای رسیدگی به خطاها و استثناها استفاده می شود.
            // نشان می دهد که یک موقعیت غیرمنتظره رخ داده است که برنامه باید به آن رسیدگی کند.
            //معمولاً با سطح ردیابی 4 همراه است.


            //E-Critical (or Fatal)
            //شدیدترین سطح ردیابی.
            // برای خطاهای بسیار بحرانی که ممکن است منجر به از کار افتادن برنامه یا تجربه شکست شدید شود، استفاده می شود.
            // موقعیت هایی را نشان می دهد که برنامه نمی تواند به طور ایمن به کار خود ادامه دهد.
            // معمولاً با سطح ردیابی 5 یا بالاتر همراه است.



            //این سطوح ردیابی روشی ساختاریافته برای اولویت‌بندی و دسته‌بندی پیام‌های گزارش یا ردیابی اطلاعات فراهم می‌کنند و تجزیه و تحلیل و تشخیص مسائل را آسان‌تر می‌کنند. بسته به چارچوب گزارش یا کتابخانه ای که استفاده می کنید، مقادیر عددی مرتبط با این سطوح ردیابی ممکن است متفاوت باشد، اما سلسله مراتب شدت یکسان باقی می ماند.






            //6.What is the difference between the Debug and Trace classes?

        }
    }



    public sealed class EventLogTraceListener : TraceListener
    {
        public override void Write(string? message)
        {
            throw new NotImplementedException();
        }

        public override void WriteLine(string? message)
        {
            throw new NotImplementedException();
        }
    }
}


 